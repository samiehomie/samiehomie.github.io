---
title: "Daily Log"
author: sam
date: 2022-12-16 16:32:00 -0500
categories: [Daily Log, Gratitude Journal]
tags: [Daily Log]
imgp: /assets/img/git/
---

나이를 먹어가며 매일 해야 하는일이 조금씩 늘어갔다.

매일 조금씩 뛰는 것, 매일 명상을 하는 것, 매일 일이 아닌 나를 위해 코드를 짜보는 것, 매일 감사 일기를 작성하는 것, 매일 영어 공부를 하는 것.

Docker는 애플리케이션을 개발, 배송 및 실행하기 위한 개방형 플랫폼이다. Docker를 사용하면 애플리케이션을 인프라에서 분리하여 소프트웨어를 신속하게 제공할 수 있으며 애플리케이션을 관리하는 것과 동일한 방식으로 인프라를 관리할 수 있다. 코드를 신속하게 전송, 테스트 및 배포하는 Docker의 방법론을 활용하여 코드를 작성하고 운영 환경에서 실행하는 데 걸리는 시간을 크게 줄일 수 있다.

## Docker란?

Docker는 컨테이너라는 느슨하게 격리된 환경에서 애플리케이션을 패키지화하고 실행할 수 있는 기능을 제공한다. 격리 및 보안을 통해 지정된 호스트에서 여러 컨테이너를 동시에 실행할 수 있다. 컨테이너는 가벼우면서 애플리케이션을 실행하는 데 필요한 모든 것을 포함하므로 호스트에 현재 설치된 것에 의존할 필요가 없다. 작업하는 동안 컨테이너를 쉽게 공유할 수 있으며, 공유하는 모든 사용자가 동일한 방식으로 작동하는 동일한 컨테이너를 사용하게 된다.

Docker는 컨테이너의 라이프사이클을 관리할 수 있는 툴과 플랫폼을 제공한다.

- 컨테이너를 사용하여 애플리케이션 및 지원 컴포넌트를 개발한다.
- 컨테이너는 애플리케이션을 배포하고 테스트하기 위한 단위가 된다.
- 준비가 되면 애플리케이션을 컨테이너 또는 오케스트레이션 서비스로 프로덕션 환경에 배포한다. 이는 프로덕션 환경이 로컬, 클라우드 또는 둘의 하이브리드인지와 상관없이 동일하게 작동한다.

## Docker를 왜 사용해야 할까

### 빠르고 일관된 애플리케이션 제공

Docker는 개발자들이 애플리케이션과 서비스를 제공하는 로컬 컨테이너를 사용하여 표준화된 환경에서 작업할 수 있도록 함으로써 개발 라이프사이클을 간소화한다. 컨테이너는 지속적 통합 과 지속적 배포(CI/CD) 워크플로우에 적합하다.

다음은 Docker를 활용하는 예시다.

- 개발자는 로컬에서 코드를 작성하고 Docker 컨테이너를 사용해 동료와 작업을 공유한다.
- Docker를 사용해 애플리케이션을 테스트 환경에서 자동 및 수동 테스트를 실행한다.
- 개발자가 버그를 발견하면 개발 환경에서 버그를 수정하고 테스트 및 검증을 위해 테스트 환경에 재배포할 수 있다.
- 테스트가 완료되면 업데이트된 이미지를 프로덕션 환경에 푸시하는 것만으로 고객에게 수정 사항을 제공할 수 있다.

### 신속한 배포 및 확장

Docker의 컨테이너 기반 플랫폼은 매우 가벼운 작업 부하를 발생시킨다. Docker 컨테이너는 랩탑, 데이터 센터의 물리 또는 가상 머신, 클라우드 환경, 클라우드/로컬 혼합 환경에서 실행될 수 있다.

Docker는 가볍기 때문에 작업 부하를 동적으로 관리하고 비즈니스 요구에 따라 애플리케이션과 서비스를 거의 실시간으로 확장 또는 해체할 수 있다.

## Docker 아키텍처

Docker는 클라이언트-서버 아키텍처를 사용한다. Docker 클라이언트는 Docker 컨테이너를 빌드, 실행 및 배포하는 작업을 처리하는 Docker 데몬과 통신한다. Docker 클라이언트와 데몬을 동일한 시스템에서 실행하거나 Docker 클라이언트를 원격 Docker 데몬에 연결할 수 있다. Docker 클라이언트와 데몬은 UNIX 소켓 또는 네트워크 인터페이스를 통한 REST API를 사용하여 통신한다. 또 다른 Docker 클라이언트인 Docker 컴포지트는 컨테이너 집합으로 구성된 애플리케이션을 사용할 수 있게 한다.

![architecture.svg](/assets/img/docker/architecture.svg)

### Docker 데몬

Docker 데몬(Dockerd)은 Docker API 요청을 수신하고 이미지, 컨테이너, 네트워크 및 볼륨과 같은 Docker 객체를 관리한다. 데몬은 다른 데몬과 통신하여 Docker 서비스를 관리할 수도 있다.

### Docker 클라이언트

Docker 클라이언트(Docker)는 많은 Docker 사용자가 Docker와 상호 작용하는 기본 방법이다. `docker run`과 같은 명령을 사용하면 클라이언트는 명령을 `dockerd`로 전송하여 이 명령을 수행한다. `docker` 명령은 Docker API를 사용한다. Docker 클라이언트는 둘 이상의 데몬과 통신할 수 있다.

### Docker 데스크톱

Docker 데스크톱은 Mac, Windows, Linux 환경을 위한 설치가 쉬운 애플리케이션으로, 컨테이너화된 애플리케이션 및 마이크로 서비스를 구축하고 공유할 수 있다. Docker 데스크톱에는 Docker 데몬(`dockerd`), Docker 클라이언트(`docker`), Docker 컴포지트, Docker 콘텐츠 트러스트, 쿠버네티스, 자격 증명 헬퍼가 포함된다.

### Docker 레지스트리

Docker 레지스트리는 Docker 이미지를 저장한다. Docker 허브는 누구나 사용할 수 있는 공용 레지스트리이며 Docker는 기본적으로 Docker 허브에서 이미지를 찾도록 설정되어 있다. 물론 개인 레지스트리를 실행할 수도 있다.

`docker pull` 또는 `docker run` 명령을 사용하면 설정된 레지스트리에서 필요한 이미지가 풀(pull)된다. `docker push` 명령을 사용하면 이미지가 설정된 레지스트리로 푸시된다.

### Docker 객체

Docker를 사용하는 경우 이미지, 컨테이너, 네트워크, 볼륨, 플러그인 및 기타 객체를 만들고 사용한다. 이 섹션에서는 이러한 객체 중 일부에 대해 간략하게 설명한다.

**이미지**

이미지는 Docker 컨테이너를 만드는 방법이 담긴 읽기 전용 템플릿이다. 종종 이미지는 추가적인 커스터마이징과 함께 다른 이미지를 기반으로 한다. 예를 들어 `ubuntu` 이미지를 기반으로 이미지를 구축하면서 Apache 웹 서버와 애플리케이션은 물론 애플리케이션을 실행하는 데 필요한 설정 세부 정보를 설치할 수 있다.

이미지를 직접 만들거나 또는 다른 사용자가 만들어 레지스트리에 게시한 이미지를 사용할 수 있다. 직접 만든 이미지를 빌드하려면 이미지를 만들고 실행하는 데 필요한 단계를 정의하기 위한 간단한 구문을 사용하여 Dockerfile을 만든다. Dockerfile의 각 명령은 이미지에 레이어를 생성한다. Dockerfile을 변경하고 이미지를 다시 빌드하면 변경된 레이어만 다시 빌드된다. 이는 다른 가상화 기술과 비교해 이미지를 매우 가볍고, 작고, 빠르게 만드는 요소다.

**컨테이너**

컨테이너는 이미지의 실행 가능한 인스턴스다. Docker API 또는 CLI를 사용하여 컨테이너를 생성, 시작, 중지, 이동 또는 삭제할 수 있다. 컨테이너를 하나 이상의 네트워크에 연결하거나, 스토리지를 연결하거나, 컨테이너의 현재 상태를 기반으로 새 이미지를 생성할 수 있다.

기본적으로 컨테이너는 다른 컨테이너 및 해당 호스트 시스템과 비교적 잘 분리된다. 컨테이너의 네트워크, 스토리지 또는 기타 기반 시스템이 다른 컨테이너 또는 호스트 시스템과 얼마나 분리되어 있는지를 제어할 수 있다.

컨테이너는 컨테이너를 만들거나 시작할 때 컨테이너에 제공하는 설정 옵션뿐만 아니라 이미지에 의해서도 정의된다. 컨테이너가 제거되면 영구 저장소에 저장되지 않은 상태의 변경 내용이 모두 사라진다.

**`docker run` 명령 예제**

다음 명령은 `ubuntu` 컨테이너를 실행하고 로컬 명령줄 세션에 대화형으로 연결하여 `/bin/bash`를 실행한다.

```bash
docker run -i -t ubuntu /bin/bash
```

이 명령을 실행하면 다음과 같은 상황이 발생한다(기본 레지스트리 설정을 사용하는 경우).

1. 로컬에 `ubuntu` 이미지가 없으면 Docker는 `docker pull ubuntu`를 수동으로 실행한 것처럼 설정된 레지스트리에서 이미지를 가져온다(pull).
2. `docker container create` 명령을 수동으로 실행한 것처럼 Docker가 새 컨테이너를 만든다.
3. Docker는 컨테이너에 읽기-쓰기 파일 시스템을 최종 레이어로 할당한다. 이렇게 하면 실행 중인 컨테이너가 로컬 파일 시스템에서 파일 및 디렉터리를 만들거나 수정할 수 있다.
4. 네트워킹 옵션을 지정하지 않았으면 Docker는 컨테이너를 기본 네트워크에 연결하는 네트워크 인터페이스를 만든다. 여기에는 컨테이너에 IP 주소를 할당하는 작업이 포함된다. 기본적으로 컨테이너는 호스트 머신의 네트워크 연결을 사용하여 외부 네트워크에 연결할 수 있다.
5. Docker가 컨테이너를 시작하고 `/bin/bash`를 실행한다. 컨테이너가 대화형으로 실행되고 터미널에 연결되어 있기 때문에(`-i` 및 `-t` 플래그 때문에) 출력이 터미널에 기록되는 동안 키보드를 사용하여 입력을 할 수 있다.
6. `exit`를 입력하여 `/bin/bash` 명령을 종료하면 컨테이너가 중지되지만 제거되지는 않는다. 따라서 다시 시작하거나 제거할 수 있다.

## 기반 기술

Dokcer는 Go 프로그래밍 언어로 작성되었으며 리눅스 커널의 여러 기능을 이용하여 기능을 제공한다. Dokcer는 `namespaces`라는 기술을 사용하여 컨테이너라는 분리된 작업 공간을 제공한다. 컨테이너를 실행하면 Docker는 해당 컨테이너의 네임스페이스 집합을 만든다.

이러한 네임스페이스는 분리된 레이어를 제공한다. 컨테이너의 각 측면은 별도의 네임스페이스에서 실행되며 액세스는 해당 네임스페이스로 제한된다.

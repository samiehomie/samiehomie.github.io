---
title: "HTTP + 메시지 브로커 vs. MQTT"
author: sam
date: 2024-09-22 18:45:00
categories: [Handbook, Protocol]
tags: [MQTT, HTTP]
imgp: /assets/img/git/
---

HTTP 클라이언트에 RabbitMQ로 대표되는 메시지 브로커 미들웨어를 사용하는 것과 MQTT 프로토콜을 사용하는 것엔 어떤 차이가 있을까.
둘 다 메시지 브로커를 두고 통신하지만 각기 목적과 용도가 다르다.

## 1. 프로토콜과 설계 철학

- RabbitMQ + HTTP: RabbitMQ는 Advanced Message Queuing Protocol(AMQP)과 같은 전송 프로토콜을 사용하며, 메시지 지향 미들웨어로 설계되었다. HTTP와 RabbitMQ를 같이 쓰는 경우에는 HTTP 요청을 통해 데이터를 보내고, 그 데이터를 RabbitMQ를 통해 비동기적으로 처리할 수 있다.
- MQTT: MQTT는 경량 메시징 프로토콜로, 사물인터넷(IoT) 환경에서 주로 사용되며, 저전력, 저대역폭 네트워크 환경에 적합하게 설계되었다. MQTT는 Publish/Subscribe 패턴을 사용하며, 연결된 장치들이 매우 적은 데이터 오버헤드로 통신할 수 있도록 설계되었다. MQTT는 일반적으로 TCP/IP를 통해 동작하며, 장치가 메시지 브로커에 메시지를 퍼블리시하고, 해당 메시지를 구독한 다른 장치가 그 메시지를 수신한다.

## 2. 메시지 전달 패턴

- RabbitMQ: 다양한 메시지 전달 패턴을 지원하며, 주로 큐 기반의 전송을 사용한다. 메시지는 브로커의 큐로 들어가고, 필요한 소비자(consumer)에게 전달된다. 복잡한 라우팅 규칙을 설정할 수 있고, 메시지의 영속성, 재시도 메커니즘 등을 지원해 더 신뢰성 있는 메시지 전송을 보장한다.
- MQTT: Pub/Sub 패턴을 사용해 퍼블리셔(publisher)와 구독자(subscriber) 사이에 매우 가볍고 단순한 구조로 메시지를 전달한다. 메시지의 우선순위를 조정하거나 라우팅하는 등의 복잡한 메시지 제어 기능은 없지만, 저전력 장치나 제한된 네트워크 환경에서 효율적인 통신을 가능하게 한다.

## 3. 신뢰성 및 메시지 품질

- RabbitMQ: 메시지 전달 품질을 보장하는 기능이 잘 갖춰져 있다. 예를 들어 메시지 영속성(persistence), 재시도(retry), 응답 대기(acknowledgment)와 같은 기능을 통해 메시지가 손실되지 않도록 할 수 있다.
- MQTT: MQTT도 메시지 품질(QoS, Quality of Service)을 지원하지만, RabbitMQ만큼 복잡한 신뢰성 보장 기능은 제공하지 않는다. 대신 MQTT는 QoS 수준을 설정해 메시지의 중복 수신이나 손실 가능성을 줄일 수 있다.
  - QoS 0: 최대 한 번 전달 (At most once)
  - QoS 1: 최소 한 번 전달 (At least once)
  - QoS 2: 정확히 한 번 전달 (Exactly once)

## 4. 대역폭과 리소스 사용

- RabbitMQ + HTTP: HTTP는 상대적으로 오버헤드가 큰 프로토콜이다. HTTP 헤더와 상태 유지 매커니즘으로 인해 더 많은 대역폭을 소비할 수 있다. 특히 IoT나 제한된 네트워크 환경에서는 비효율적일 수 있다.
- MQTT: MQTT는 매우 경량화되어 있어서 저전력 기기와 제한된 네트워크 대역폭 환경에 더 적합하다. 연결 유지(keep-alive)와 같은 기능이 있으며, 메시지 오버헤드가 매우 적다.

## 5. 사용 사례

- RabbitMQ + HTTP: 비동기적인 작업 큐를 구현하거나, 백엔드 마이크로서비스 사이의 메시지 전달이 필요한 경우에 적합하다. 일반적으로 HTTP 기반 시스템과의 통합이 쉽고, 복잡한 라우팅과 신뢰성 있는 메시지 처리가 필요한 경우 사용됩니다.
- MQTT: IoT 장치 간의 통신, 실시간 모니터링, 원격 센서 데이터 수집 등의 상황에 적합합니다. 특히 저전력, 저대역폭 장치가 많을 때 유리하다.

## MQTT는 왜 가볍고 어떻게 메시지 전달으 보장하는가

MQTT가 인터넷이 불안정한 상황에서 문제를 해결할 수 있는 이유는 그 특성상 **경량**이며, **연결 복구**와 **메시지 품질 보장(QoS)**에 신경 쓴 설계 덕분이다. 이러한 기능들은 불안정한 네트워크 환경에서도 데이터를 안정적으로 전송하거나 재전송하도록 돕는다.

### 1. 경량 프로토콜

MQTT는 매우 작은 데이터 패킷과 최소한의 헤더를 사용하여 데이터를 주고받는다. 이는 대역폭이 제한되거나 인터넷이 불안정한 환경에서도 데이터를 효율적으로 전달할 수 있게 한다. 일반적인 HTTP 프로토콜보다 훨씬 가벼운 구조이기 때문에, **데이터를 빠르게 전송**하고, 손실 위험을 줄이는 데 도움이 된다.

### 2. QoS (Quality of Service): 메시지 전달 품질 보장

MQTT는 3가지 수준의 QoS(Quality of Service)를 제공하여, 네트워크 연결이 불안정할 때 메시지의 전달 신뢰성을 보장한다.

- **QoS 0**: 최대 1번 전송 (At most once) - 메시지가 손실될 수 있지만, 데이터 전송 속도가 빠르다.
- **QoS 1**: 최소 1번 전송 (At least once) - 메시지가 적어도 한 번 전달되며, 중복 메시지가 발생할 수 있다. 네트워크 장애가 발생해도 브로커와 클라이언트는 메시지 전송을 재시도하여 손실을 방지한다.
- **QoS 2**: 정확히 1번 전송 (Exactly once) - 메시지가 중복 없이 한 번만 전송된다. 이 방식은 신뢰성이 가장 높지만, 상대적으로 더 많은 트래픽과 시간이 필요하다.

### 3. 지속 연결 (Persistent Connection) 및 연결 복구
   
MQTT는 기본적으로 클라이언트와 브로커 간에 **지속적인 연결**을 유지하는 구조로 동작한다. 클라이언트가 브로커에 연결된 상태에서 메시지를 주고받으며, 연결이 끊어졌을 때 자동으로 **연결을 복구**하는 메커니즘이 내장되어 있다.

- 연결이 끊긴 경우에도 클라이언트는 연결이 복구되면 다시 서버에 연결하여 통신을 이어가며, QoS에 따라 **메시지를 재전송**할 수 있다.
- 또한 **Last Will and Testament**라는 기능을 통해, 클라이언트가 예기치 않게 연결이 끊길 경우 이를 브로커와 다른 구독자에게 알릴 수 있어, 네트워크 불안정성에 대처할 수 있다.

### 4. 오프라인 메시지 처리

MQTT 브로커는 클라이언트가 오프라인 상태일 때도 메시지를 저장해두었다가, 클라이언트가 다시 온라인이 되었을 때 전달할 수 있다. 특히 QoS 수준이 1 또는 2일 때 브로커가 메시지를 보관하고, 클라이언트가 연결되면 이를 다시 보내주는 방식으로 동작한다. 이 기능은 인터넷 연결이 일시적으로 끊겼다가 다시 복구되었을 때 데이터 손실을 방지하는 데 유용하다.

### 5. Keep-alive 및 적응형 재연결

MQTT는 **Keep-alive** 기능을 통해 주기적으로 작은 패킷을 보내어 연결 상태를 유지한다. 이를 통해 연결이 끊어졌는지 감지할 수 있으며, 끊어졌을 때 빠르게 재연결을 시도할 수 있습니다. 이 과정에서 MQTT 클라이언트는 지능적으로 재연결을 시도하며, 주기적으로 연결 상태를 체크하여 불안정한 네트워크에서 신속하게 복구할 수 있습니다.
